#[cfg(test)]
mod tests;

use std::{
	collections::BTreeMap,
	fmt::Write,
	fs,
	process,
};

use anyhow::{
	anyhow,
	bail,
	Context,
	Result,
};
use clap::Parser;
use mappings::{
	Library,
	Mapping,
};
use midly::{
	num::{
		u15,
		u24,
		u28,
		u4,
		u7,
	},
	Format,
	Header,
	MetaMessage,
	MidiMessage,
	Smf,
	Timing,
	TrackEvent,
	TrackEventKind,
};
fn generate_sweep() -> Smf<'static> {
	let header = Header::new(Format::SingleTrack, Timing::Metrical(u15::new(1000)));
	let mut smf = Smf::new(header);
	let mut track = Vec::with_capacity(131);
	track.push(TrackEvent {
		delta: u28::new(0),
		kind: TrackEventKind::Meta(MetaMessage::Tempo(u24::new(1000000))),
	});

	track.extend((0..=127).flat_map(|n| {
		let on = TrackEvent {
			delta: u28::new(if n == 0 { 0 } else { 250 }),
			kind: TrackEventKind::Midi {
				channel: u4::new(9),
				message: MidiMessage::NoteOn {
					key: u7::new(n),
					vel: u7::new(86),
				},
			},
		};
		let off = TrackEvent {
			delta: u28::new(750),
			kind: TrackEventKind::Midi {
				channel: u4::new(9),
				message: MidiMessage::NoteOff {
					key: u7::new(n),
					vel: u7::new(0),
				},
			},
		};

		[on, off]
	}));

	track.push(TrackEvent {
		delta: u28::new(10000),
		kind: TrackEventKind::Meta(MetaMessage::EndOfTrack),
	});

	smf.tracks.push(track);

	smf
}

#[derive(Parser)]
/// Generate midi drum note mappings
enum Args {
	Template(Template),
	Generate(Generate),
	Remap(Remap),
}

#[derive(Parser)]
/// Generate a dummy midi file for input to a converter
struct Template {
	#[arg(short, long)]
	/// The .mid file to write to
	out: String,
}

#[derive(Parser)]
/// Generate a mapping file based on the .mid file generated by `template` and a
/// mapped file
struct Generate {
	#[arg()]
	/// The path to the remapped .mid file
	input: String,
	#[arg(short, long, default_value = "-")]
	/// The Path to write to, "-" for stdout.
	out: String,
}

#[derive(Parser)]
/// Remap a midi file.
struct Remap {
	#[arg()]
	/// The midi file to remap.
	input: String,
	#[arg(short, long)]
	/// The output file path that'll be created.
	out: String,

	#[arg(short, long, value_enum, default_value_t = Library::DEFAULT)]
	/// The mapping of the original midi file.
	/// Overwritten by --from-mapping
	from: Library,
	#[arg(short = 'F', long)]
	/// The original mapping, read from a file.
	from_mapping: Option<String>,

	#[arg(short, long, value_enum, required_unless_present = "to_mapping")]
	/// The library to map to.
	to: Option<Library>,
	#[arg(short = 'T', long)]
	/// The mapping to map to, read from a file.
	to_mapping: Option<String>,

	#[arg(short, long, default_value_t = 10, value_parser = clap::value_parser!(u8).range(0..=16))]
	/// Map only notes on the channel provided (1-16); specify 0 to map all
	/// channels.
	channel: u8,
}

impl Args {
	fn run(self) -> Result<()> {
		match self {
			Self::Template(x) => x.run(),
			Self::Remap(x) => x.run(),
			Self::Generate(x) => x.run(),
		}
	}
}

impl Template {
	fn run(self) -> Result<()> {
		generate_sweep().save(self.out)?;
		Ok(())
	}
}

impl Generate {
	fn run(self) -> Result<()> {
		let data = fs::read(&self.input)?;
		let (_, tracks) = midly::parse(&data)?;

		for (index, t) in tracks.enumerate() {
			let Ok(t) = t else {
				eprintln!("warning: failed to decode track {index}");
				continue;
			};
			let mut buf = String::with_capacity(4096);
			let notes = t.flatten().filter_map(|e| match e.kind {
				TrackEventKind::Midi {
					channel,
					message: MidiMessage::NoteOn { key, .. },
				} if channel.as_int() == 9 => Some(key.as_int()),
				_ => None,
			});

			let mut n = 0;
			for (from, to) in notes.enumerate() {
				n += 1;
				if from > 127 {
					break;
				}
				let _ = writeln!(buf, "{from} -> {to}");
			}

			if n != 128 {
				eprintln!("warning: unexpected track {index} contains {n} notes, expected 128 -- ignoring");
				continue;
			}

			if self.out == "-" {
				println!("{buf}");
			} else {
				fs::write(&self.out, buf.as_bytes())?;
			}
			return Ok(());
		}

		Err(anyhow!("couldn't find the remapped track in the file {}; make sure that the remapped track contains exactly 128 midi note on events on channel 9 (counting from 0)", self.input))
	}
}

impl Remap {
	fn run(self) -> Result<()> {
		let from = match &self.from_mapping {
			None => *self.from.get_mapping(),
			Some(p) => parse_mapping(p)?,
		};

		let to = match self.to {
			Some(x) => *x.get_mapping(),
			None => parse_mapping(self.to_mapping.as_ref().unwrap())?,
		};

		let data = fs::read(&self.input).with_context(|| format!("reading file {}", self.input))?;
		let (header, tracks) = midly::parse(&data).context("parsing input file")?;
		let tracks = tracks.collect_tracks()?;

		let map = |n: u7| -> u7 { u7::new(from.to(&to, n.as_int())) };

		let mapped = tracks
			.into_iter()
			.map(|t| {
				t.into_iter()
					.map(|e| match e.kind {
						TrackEventKind::Midi { channel, message } => TrackEvent {
							delta: e.delta,
							kind: TrackEventKind::Midi {
								channel,
								message: match message {
									x if self.channel != 0
										&& self.channel - 1 != channel.as_int() =>
									{
										x
									}
									MidiMessage::NoteOff { key, vel } => {
										MidiMessage::NoteOff { vel, key: map(key) }
									}
									MidiMessage::NoteOn { key, vel } => {
										MidiMessage::NoteOn { vel, key: map(key) }
									}
									MidiMessage::Aftertouch { key, vel } => {
										MidiMessage::Aftertouch { vel, key: map(key) }
									}
									other => other,
								},
							},
						},
						other => TrackEvent {
							delta: e.delta,
							kind: other,
						},
					})
					.collect::<Vec<_>>()
			})
			.collect::<Vec<_>>();

		let mut out_data = Vec::with_capacity(data.len());
		midly::write(&header, &mapped, &mut out_data)
			.map_err(|e| anyhow!("failed to generate midi data: {e}"))?;
		fs::write(&self.out, &out_data).with_context(|| format!("writing to {}", self.out))?;

		Ok(())
	}
}

fn parse_mapping(p: &str) -> Result<Mapping> {
	let data = fs::read_to_string(p)?;
	let mut map = BTreeMap::new();
	for (i, s) in data.lines().enumerate().filter(|t| !t.1.trim().is_empty()) {
		let (gm, to) =
			s.split_once(" -> ").ok_or_else(|| {
				anyhow!("the file {p}, line {i}: invalid mapping (should be `note_number -> note_number`)")
			})?;

		let gm = gm.parse::<u8>().map_err(|_| {
			anyhow!("the file {p}, line {i}: invalid line: {gm} isn't a valid note number")
		})?;
		let to = to.parse::<u8>().map_err(|_| {
			anyhow!("the file {p}, line {i}: invalid line: {to} isn't a valid note number")
		})?;
		if gm > 127 {
			bail!("the file {p}, line {i}: invalid line: {gm} isn't a valid note number");
		}
		if to > 127 {
			bail!("the file {p}, line {i}: invalid line: {to} isn't a valid note number");
		}

		map.insert(gm, to);
	}

	// This should be impossible
	if map.len() > 128 {
		bail!("the file {p} contains more than 128 mappings");
	}

	let mut from_gm = [0; 128];
	let mut to_gm = [0; 128];

	for i in 0_u8..=127 {
		from_gm[i as usize] = map.get(&i).copied().unwrap_or(i);
		to_gm[i as usize] = i;
	}

	for (&gm, &to) in &map {
		to_gm[to as usize] = gm;
	}

	Ok(Mapping { from_gm, to_gm })
}

fn main() {
	if let Err(e) = Args::parse().run() {
		eprintln!("error: {e}");
		process::exit(1);
	}
}
