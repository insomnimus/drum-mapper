use std::{
	fmt::Write,
	fs,
	process,
};

use anyhow::{
	anyhow,
	Result,
};
use clap::Parser;
use midly::{
	num::{
		u15,
		u24,
		u28,
		u4,
		u7,
	},
	Format,
	Header,
	MetaMessage,
	MidiMessage,
	Smf,
	Timing,
	TrackEvent,
	TrackEventKind,
};

fn generate_sweep() -> Smf<'static> {
	let header = Header::new(Format::SingleTrack, Timing::Metrical(u15::new(1000)));
	let mut smf = Smf::new(header);
	let mut track = Vec::with_capacity(131);
	track.push(TrackEvent {
		delta: u28::new(0),
		kind: TrackEventKind::Meta(MetaMessage::Tempo(u24::new(1000000))),
	});

	track.extend((0..=127).flat_map(|n| {
		let on = TrackEvent {
			delta: u28::new(if n == 0 { 0 } else { 250 }),
			kind: TrackEventKind::Midi {
				channel: u4::new(9),
				message: MidiMessage::NoteOn {
					key: u7::new(n),
					vel: u7::new(86),
				},
			},
		};
		let off = TrackEvent {
			delta: u28::new(750),
			kind: TrackEventKind::Midi {
				channel: u4::new(9),
				message: MidiMessage::NoteOff {
					key: u7::new(n),
					vel: u7::new(0),
				},
			},
		};

		[on, off]
	}));

	track.push(TrackEvent {
		delta: u28::new(10000),
		kind: TrackEventKind::Meta(MetaMessage::EndOfTrack),
	});

	smf.tracks.push(track);

	smf
}

#[derive(Parser)]
/// Generate midi drum note mappings
enum Args {
	Generate(Generate),
	Map(Map),
}

#[derive(Parser)]
/// Generate a dummy midi file for input to a converter
struct Generate {
	#[arg(short, long)]
	/// The .mid file to write to
	out: String,
}

#[derive(Parser)]
/// Generate a mapping file based on the .mid file generated by `generate` and a
/// mapped file
struct Map {
	#[arg(short, long)]
	/// The path to the remapped .mid file
	input: String,
	#[arg(short, long, default_value = "-")]
	/// The Path to write to, `-` for stdout.
	out: String,
}

impl Args {
	fn run(self) -> Result<()> {
		match self {
			Self::Generate(g) => g.run(),
			Self::Map(m) => m.run(),
		}
	}
}

impl Generate {
	fn run(self) -> Result<()> {
		generate_sweep().save(self.out)?;
		Ok(())
	}
}

impl Map {
	fn run(self) -> Result<()> {
		let data = fs::read(&self.input)?;
		let (_, tracks) = midly::parse(&data)?;

		for (index, t) in tracks.enumerate() {
			let Ok(t) = t else {
				eprintln!("warning: failed to decode track {index}");
				continue;
			};
			let mut buf = String::with_capacity(4096);
			let notes = t.flatten().filter_map(|e| match e.kind {
				TrackEventKind::Midi {
					channel,
					message: MidiMessage::NoteOn { key, .. },
				} if channel.as_int() == 9 => Some(key.as_int()),
				_ => None,
			});

			let mut n = 0;
			for (from, to) in notes.enumerate() {
				n += 1;
				if from > 127 {
					break;
				}
				let _ = writeln!(buf, "{from} -> {to}");
			}

			if n != 128 {
				eprintln!("warning: unexpected track {index} contains {n} notes, expected 128 -- ignoring");
				continue;
			}

			if self.out == "-" {
				println!("{buf}");
			} else {
				fs::write(&self.out, buf.as_bytes())?;
			}
			return Ok(());
		}

		Err(anyhow!("couldn't find the remapped track in the file {}; make sure that the remapped track contains exactly 128 midi note on events on channel 9 (counting from 0)", self.input))
	}
}

fn main() {
	if let Err(e) = Args::parse().run() {
		eprintln!("error: {e}");
		process::exit(1);
	}
}
